{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### CS375-Project 4: Stop-and-wait protocol\n",
    "### Submitted by: Anubhav Adhikari, Brendon Jean-Baptiste\n",
    "### Submitted to: Dr. Jessen Havill\n",
    "### Date: April 18, 2022\n",
    "\n",
    "### Project 4: \n",
    "In this project, we implemented a simple stop-and-wait protocol between a client and a server. Here, the client sends an initial packet as a request to the server to initiate a connection, and subsequently sends packets of data to the server. The server acknowledges the packet, and sends an ACK to the client with the opposite sequence number. We keep track of new packets by analyzing the sequence number `seqVal` that is sent by either client or server. If the sequence number is same as the last packet's, then the same packet has been resent and there has either been a problem in the transmission, or the timeout was activated in the client.\n",
    "\n",
    "### Packet:\n",
    "In this project, the packet is a 1032 byte unsigned char array, divided further into these unsigned char arrays: `seqnum` (4 bytes), `ack` (1 byte), `control` (1 byte), `length` (2 bytes), `data` (1024 bytes, at maximum).\n",
    "```c\n",
    "  unsigned char seqnum[4];\n",
    "  unsigned char ack[1];\n",
    "  unsigned char control[1];\n",
    "  unsigned char length[2];\n",
    "  char data [1024];\n",
    "```\n",
    "\n",
    "### Build Packet:\n",
    "We implemented a function `buildPacket` that combines all the different variables into the final packet `packet`:\n",
    "```c\n",
    "void buildPacket(unsigned int seqnum_temp, unsigned int ack_temp, unsigned int control_temp, unsigned int length_temp,\n",
    "  char data_1[1024], unsigned char (*packet)[])\n",
    "{\n",
    "  unsigned char seqnum[4];\n",
    "  unsigned char ack[1];\n",
    "  unsigned char control[1];\n",
    "  unsigned char length[2];\n",
    "\n",
    "  unsigned int new_int = htonl(seqnum_temp);\n",
    "  memcpy(seqnum, &new_int, 4);\n",
    "  memcpy(ack, &ack_temp, 1);\n",
    "  memcpy(control, &control_temp, 1);\n",
    "  unsigned int new_int_1 = htons(length_temp);\n",
    "  memcpy(length, &new_int_1, 2);\n",
    "\n",
    "  //----------------------------------------------------------------------------\n",
    "\t//combining all the char arrays into 'packet' array\n",
    "\tint index = 0;\n",
    "\n",
    "  for(int i = 0; i < sizeof(seqnum); i++){\n",
    "    (*packet)[index] = seqnum[i];\n",
    "    index = index + 1;\n",
    "  }\n",
    "  for(int i = 0; i < sizeof(ack); i++){\n",
    "    (*packet)[index] = ack[i];\n",
    "    index = index + 1;\n",
    "  }\n",
    "  for(int i = 0; i < sizeof(control); i++){\n",
    "    (*packet)[index] = control[i];\n",
    "    index = index + 1;\n",
    "  }\n",
    "  for(int i = 0; i < sizeof(length); i++){\n",
    "    (*packet)[index] = length[i];\n",
    "    index = index + 1;\n",
    "  }\n",
    "  for(int i = 0; i < strlen(data_1)-1; i++){\n",
    "    (*packet)[index] = data_1[i];\n",
    "    index = index + 1;\n",
    "  }\n",
    "\t(*packet)[index] = '\\0';\n",
    "}\n",
    "```\n",
    "\n",
    "### Unpack Packet:\n",
    "Once a packet is sent to the server/client, it is unpacked, so that the content can be transferred back to their original variable types and used for further logic in the code (for example, `seqnum` is an unsigned int). We implemented a function `unpackPacket` that unpacks the packet:\n",
    "```c\n",
    "void unpackPacket(char (*buffer)[], unsigned int (*returnArr)[]){\n",
    "\n",
    "  unsigned int b0 = (*buffer)[0];\n",
    "  unsigned int b1 = (*buffer)[1];\n",
    "  unsigned int b2 = (*buffer)[2];\n",
    "  unsigned int b3 = (*buffer)[3];\n",
    "  unsigned int seqnum1 = (b0 << 24) + (b1 << 16) + (b2 << 8) + b3; //converting bytes back to int\n",
    "  (*returnArr)[0] = seqnum1;\n",
    "\n",
    "  unsigned int c0;\n",
    "  c0 = (*buffer)[4];\n",
    "  unsigned int ack1 = c0; //converting bytes back to int\n",
    "  (*returnArr)[1] = ack1;\n",
    "\n",
    "  unsigned int t0;\n",
    "  t0 = (*buffer)[5];\n",
    "  unsigned int control1 = t0; //converting bytes back to int\n",
    "  (*returnArr)[2] = control1;\n",
    "\n",
    "  unsigned int l0,l1;\n",
    "  l0 = (*buffer)[6];\n",
    "  l1 = (*buffer)[7];\n",
    "  unsigned int length1 = (l0 << 8) + l1; //converting bytes back to int\n",
    "  (*returnArr)[3] = length1;\n",
    "\n",
    "}\n",
    "```\n",
    "\n",
    "### Initiate Connection:\n",
    "To initiate a connection with the server, the client sends an initial packet with `control` value as `1`, indicating that it is trying to connect with the server. The server makes this check by unpacking the packet, and checking the `control` value, which is stored in the variable `returnArr[2]`. If it finds that this is the first packet received from this client (`initial == True`), then it sends the first ACK back, as follows:\n",
    "```c\n",
    "  if(returnArr[2] == 1 && initial){\n",
    "      printf(\"Sending initial packet...\");\n",
    "      seqVal = returnArr[0];\n",
    "      buildPacket(seqVal, 1, 1, 0, data, &packet);\n",
    "      sendto(sockfd, packet, sizeof(packet), 0, (struct sockaddr *)&sender_addr, addr_len);\n",
    "    }\n",
    "```\n",
    "\n",
    "### Teardown Connection:\n",
    "To teardown a connection and close the sockets, the client sends a packet with `control` value 2, which the server reads and uses as a signal to close the connection.\n",
    "\n",
    "### Server Logic: Stop-and-wait\n",
    "In the server, the packet that is received is unpacked, and the `control` value is checked, to see which type of message the packet is intending to transmit. We have seen that `control` with value 1 and 2 indicate connection setup and teardown respectively. When a packet arrives with `control` value 0, it is indicative of a packet with some data. \n",
    "\n",
    "The value for `control` is unpacked into the variable `returnArr[2]` by the `unpackPacket` function. After checking for the `control` value, the server checks to see if the sequence number in the packet, unpacked into the variable `returnArr[0]` is the same as the last packet's sequence number, stored in the variable `seqVal`. If it is the same, then the server will assume that the ACK for that last packet never got received by the client, so it will resend that same packet, that has been backed up in the variable `packetBackup`. If it is a new packet, then the server will create a new ACK and send it to the client.\n",
    "```c\n",
    "else if(returnArr[2] == 0 && !initial){\n",
    "    if(seqVal == returnArr[0]){\n",
    "        sendto(sockfd, packetBackup, sizeof(packet), 0, (struct sockaddr *)&sender_addr, addr_len);\n",
    "    }\n",
    "    else{\n",
    "       seqVal = returnArr[0];\n",
    "       buildPacket(abs(seqVal-1), 1, 0, 0, data, &packet);\n",
    "       strcpy(packetBackup,packet);\n",
    "       sendto(sockfd, packet, sizeof(packet), 0, (struct sockaddr *)&sender_addr, addr_len);\n",
    "    }\n",
    "}\n",
    "```\n",
    "\n",
    "### Client Logic: Stop-and-wait\n",
    "In the client, before a packet is sent, the user is prompted to type a message in the terminal, which is received as the `data` that will be appended to the `packet`. This is done through the `fgets` function, as follows:\n",
    "```c\n",
    "   fgets(data, 1024, stdin);\n",
    "```\n",
    "Once a packet is sent to the server, the client waits for an ACK. If it does not receive an ACK, after a certain timeout, it resends the packet. The timeout is implemented using the `struct timeval` library, as follows:\n",
    "```c\n",
    "struct timeval timeout;\n",
    "timeout.tv_sec = 0.5;\n",
    "timeout.tv_usec = 0;\n",
    "if(setsockopt(sockfd,SOL_SOCKET,SO_RCVTIMEO,&timeout,sizeof(timeout)) > 0)\n",
    "{\n",
    "    perror(\"Error\");\n",
    "\texit(1);\n",
    "}\n",
    "```\n",
    "Once a client resends a packet, it will enter a second while loop, that will continue resending the packet until an ACK is received for that packet. It checks for a new ACK by comparing the sequence number `seqnum_temp` it last sent, to the new sequence number it unpacked and stored in the variable `returnArr[0]`, as follows:\n",
    "```c\n",
    "while(1){\n",
    "    if(seqnum_temp == returnArr[0])\n",
    "\t{\n",
    "        sendto(sockfd, packet, sizeof(packet), 0, ptr->ai_addr, ptr->ai_addrlen);\n",
    "\t\trecvfrom(sockfd,buffer,MAXBUFLEN -1, 0, (struct sockaddr *) &their_addr, &addr_len);\n",
    "\t}\n",
    "\telse\n",
    "\t{\n",
    "\t\tbreak;\n",
    "\t}\n",
    "}\n",
    "```\n",
    "### Further Considerations:\n",
    "In the scope of this project, the `data` sent by the client does not get unpacked by the server. Right now, we have worked on the stop-and-wait protocol only, ensuring that any lost packets can be retransmitted and there is reliable data transmission. Further work can be done on this project, particularly to save the `data` in the server side, and create a message history, or a messaging system.\n",
    "\n",
    "In this way, we have implemented a stop-and-wait protocol."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
